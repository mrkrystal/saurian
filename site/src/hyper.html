<!doctype html>
<meta charset="utf-8">
<title>Saurian Translator</title>

<style>
    @import 'styles/reset.css';
    @import 'styles/body.css';
    @import 'styles/app.css';
    @import 'styles/helpers.css';
</style>

<div id="app"></div>

<script src="https://unpkg.com/hyperhtml@2.13.0/min.js"></script>

<script>

const {bind, wire} = hyperHTML;

const detectProperNouns = (text, properNounRegex) => {
    return text.split('\\').map((part, index, list) => {
        if (index % 2 !== 0) {
            return part;
        }

        // Surround all capital words that are not "I" contractions with backslashes
        // In Saurian to English version, the "I" contractions are actually "A" contractions
        part = part.replace(properNounRegex, '\\$&\\');

        // Remove the surrounding backslashes for capital words at the beginning of sentences
        part = part.replace(/([\.\!\?][\s'"]+)\\([A-Za-z0']+)\\/g, '$1$2');

        if (index === 0) {
            // At the very beginning of the string, undo any proper noun values for a capital word that appears first
            part = part.replace(/^([\s'"]*)\\([A-Za-z0']+)\\/g, '$1$2');
        }

        return part;
    }).join('\\');
};

const translate = (text, conversion) => {
    return text.split('').map((c) => {
        const charCode = c.charCodeAt(0);
        return 65 <= charCode && charCode <= 122 ? conversion.charAt(charCode - 65) : c;
    }).join('');
};

const engToSau = (text) => {
    return translate(text, 'URSTOVWXAZBCMDEFGHJKILNP0Q[\\]^_`urstovwxazbcmdefghjkilnp0q');
};

// Preprocess Saurian Y, differentiating it from zero character (0)
const preprocessSaurianY = (text) => {
    return text
        // Case: first word starts with a Saurian Y
        .replace(/(^[\s'"]*)0([A-Za-z'])/g, "$1Y$2")

        // Case: sentences beginning with a Saurian Y
        .replace(/([\.\!\?][\s'"]+)0([A-Za-z'])/g, "$1Y$2")

        // Case: all other non-numerical Saurian Y's
        .replace(/([^0-9])0([^0-9\.]|(\.[^0-9]))/g, "$1y$2");
};

const sauToEng = (text) => {
    return translate(preprocessSaurianY(text), 'IKLNOPQRUSTVMWEXZBCDAFGHYJ[\\]^_`iklnopqrustvmwexzbcdafghyj');
};

const translateNonProperNouns = (text, conversion) => {
    return text.split('\\').map((part, index) => {
        return index % 2 ? part : conversion(part);
    }).join('');
};

const state = {
    English: {
        title: 'English',
        isFocused: false,
        isSpellchecked: true,
        placeholder: 'Start typing to begin translation.',
        text: '',
    },
    Saurian: {
        title: 'Saurian',
        isFocused: false,
        isSpellchecked: false,
        placeholder: 'Jkuhk k0fadw ke rowad khudjcukaed.',
        text: '',
    },
    Pronunciation: {
        isOpen: false,
        i: '',
        c: '',
    },
};

const onAct = (type, data) => {
    if (type === 'setText' && data.source === 'English') {
        state.English.text = data.value;
        state.Saurian.text = translateNonProperNouns(state.English.text, engToSau);
    }
    else if (type === 'setText' && data.source === 'Saurian') {
        state.Saurian.text = data.value;
        state.English.text = translateNonProperNouns(state.Saurian.text, sauToEng);
    }
    else if (type === 'setFocus') {
        state[data.source].isFocused = data.value;
    }
    else if (type === 'detectProperNouns' && data.source === 'English') {
        state.English.text = detectProperNouns(state.English.text, (/\b[A-HJ-Z][A-Za-z']+|I[A-Za-z][A-Za-z']*/g));
        state.Saurian.text = toSaurian(state.English.text);
    }
    else if (type === 'detectProperNouns' && data.source === 'Saurian') {
        state.Saurian.text = detectProperNouns(state.Saurian.text, (/\b[B-Z][A-Za-z']+|A[A-Za-z][A-Za-z']*/g));
        state.English.text = toEnglish(state.Saurian.text);
    }
    else if (type === 'togglePronunciation') {
        state.Pronunciation.isOpen = data.isOpen;
    }
    else {
        // No change, no render
        return;
    }

    render(state);
};

const cache = {
    English: {},
    Saurian: {},
};

const parseWordsAsPositionedObjects = (text, cacheName) => {
    // Splitting with the group capture retains the delimiter
    const parts = text.split(/(\s+)/g);

    const pastItems = cache[cacheName];
    const wordsUsedCounts = {};
    const wordsUsedLists = {};

    // Preserve object references from call to call by checking references before creating
    const partsObjs = parts.map((part, index) => {
        wordsUsedCounts[part] = wordsUsedCounts[part] || 0;
        wordsUsedLists[part] = wordsUsedLists[part] || [];

        let ref;
        if (wordsUsedCounts[part] < (pastItems[part] || []).length) {
            ref = pastItems[part][wordsUsedCounts[part]];
            wordsUsedCounts[part] += 1;
        }
        else {
            ref = {
                t: part,
            };
        }

        wordsUsedLists[part].push(ref);
        return ref;
    });

    // Update object caches with actual used words
    // GC will remove object references no longer used
    cache[cacheName] = wordsUsedLists;

    return partsObjs;
};

const Highlights = (state) => {
    const parts = parseWordsAsPositionedObjects(state.text, state.title);

    return wire(state, ':Highlights')`
        <div class="highlight">${parts.map((part, index) => (
            wire(part, ':Span')`
                <span class=${`type${index % 2}`}>${part.t}</span>
            `
        ))}</div>
    `;
};

const Language = (state) => {
    const onDetectProperNouns = () => {
        onAct('detectProperNouns', {
            source: state.title,
        });
    };

    const onChangeText = (e) => {
        onAct('setText', {
            source: state.title,
            value: e.target.value,
        });
    };

    const onFocus = () => {
        onAct('setFocus', {
            source: state.title,
            value: true,
        });
    };

    const onBlur = () => {
        onAct('setFocus', {
            source: state.title,
            value: false,
        });
    };

    const focusClass = state.isFocused ? 'focus' : '';

    return wire(state, ':Language')`
        <div class="title">
            <label for=${state.title}>${state.title}</label>
            <button onclick=${onDetectProperNouns} disabled=${state.text.length === 0} tab-index="0" type="button">Detect Proper Nouns</button>
        </div>

        <div class=${`textBox ${focusClass}`}>
            ${Highlights(state)}
            <textarea id=${state.title} value=${state.text} oninput=${onChangeText} onfocus=${onFocus} onblur=${onBlur} placeholder=${state.placeholder} autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck=${state.isSpellchecked} tab-index="0"></textarea>
        </div>
    `;
};

const Pronunciations = (state) => {
    return wire(state, ':Pronunciations')`
        <div class="itemBox">
            <div class="title">
                <label>IPA</label>
                <a href="https://infogalactic.com/info/International_Phonetic_Alphabet" class="icon" tab-index="0">?</a>
            </div>
            <div class="pronunciation">${state.i}</div>
        </div>

        <div class="itemBox">
            <div class="title">
                <label>Common Pronunciation</label>
            </div>
            <div class="pronunciation">${state.c}</div>
        </div>
    `;
};

const Pronunciation = (state) => {
    const onToggle = () => {
        onAct('togglePronunciation', {
            isOpen: !state.isOpen,
        });
    };

    const isOpenClass = state.isOpen ? '' : 'hide';
    const buttonText = state.isOpen ? '▼ Hide Pronunciations' : '▶ Show Pronunciations';

    return wire(state, ':Pronunciation')`
        <div class=${`pronunciationBox ${isOpenClass}`}>
            <button onclick=${onToggle} tab-index="0" type="button">${buttonText}</button>

            <div class="items">
                ${state.isOpen ? Pronunciations(state) : null}
            </div>
        </div>
    `;
};

const Layout = (state, path, onChange) => {
    return wire(state, ':Layout')`
        <div class="formBox">
            <div class="form">
                <div class="items">
                    <div class="itemBox">
                        ${Language(state.English)}
                    </div>

                    <div class="itemBox">
                        ${Language(state.Saurian)}
                    </div>
                </div>

                ${Pronunciation(state.Pronunciation)}
            </div>
        </div>
    `;
};

const render = (state) => {
    bind(document.getElementById('app'))`<div class="app">${Layout(state)}</div>`;
};

{
    render(state);
}

</script>